/*
 * novacom usb
 */
var async   = require('async'),
    child_process = require('child_process'),
    fs      = require('fs'),
    log = require('npmlog'),
    net     = require('net'),
    path    = require('path'),
    shelljs = require('shelljs'),
    stream = require('stream'),
    Validator = require('jsonschema').Validator;

(function() {
    var novacom_usb = {};
    var usb = this;

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = novacom_usb;
    }

    log.heading = "novacom-usb";
    log.level = "verbose";
    novacom_usb.log = log;

    function _getNovacomPath (daemon) {
         log.silly("NovacomDB#_getNovacomPath()");
        var query = 'novacom';
        if (typeof daemon !== 'undefined' && daemon === true) {
            query = 'novacomd';
         }
        if (typeof _getNovacomPath[query] === 'undefined') {
            var novacom = (process.platform === 'win32')? query+'.exe' : query;
            var deployPath = path.resolve(__dirname, "..", "bin", novacom);
            var devPath = (process.platform === 'linux')?
                path.resolve(__dirname, "..", query, process.platform, novacom)
                : path.resolve(__dirname, "..", query, process.platform, novacom);

            if (fs.existsSync(deployPath)) {
                _getNovacomPath[query] = deployPath;
            } else if (fs.existsSync(devPath)) {
                _getNovacomPath[query] = devPath;
            } else {
                log.verbose("No " + query + " in path (" + deployPath + ", " + devPath + ")");
            }
        }
        log.verbose("NovacomDB#_getNovacomPath()#",query, _getNovacomPath[query]);
        return _getNovacomPath[query];
    }

    function _getNovacomDaemonPath () {
        return _getNovacomPath(true);
     }

    function _getFreePort (next) {
        log.verbose("NovacomUSB#_getFreePort()");
        var server = net.createServer();

        server.on('error', function (err) {
            log.info("NovacomUSB#_getFreePort()", "error!");
            return setImmediate(next, err);
        });
        server.listen(0, function () {
            port = server.address().port;
            server.close(function () {
                log.info("NovacomUSB#_getFreePort()", "port", port);
                return setImmediate(next, null, port);
            });
        });
    }

    function _checkSchema(data, schemaFile, next) {
        log.verbose("NovacomUSB#_checkSchema()", "data:", data, "schemaFile", schemaFile);
        var schemaName = '/'+path.basename(schemaFile).split('.')[0];
        var schemaArray = {
            "id": "test",
            "type": "array",
            "items": {
                "$ref": schemaName+"Schema"
            }
        };
        var stats = fs.statSync(schemaFile);
        if (stats.isFile()) {
            var schemaData = fs.readFileSync(schemaFile, "utf8"),
                result,
                schema,
                errMsg,
                v = new Validator();
            try {
                schema = JSON.parse(schemaData);
                v.addSchema(schema, schemaName);
                result = v.validate(data, schemaArray);

                if (result && result.errors.length > 0) {
                    errMsg = "";
                    errMsg = errMsg.concat("Invalid data! schema:", schemaFile);
                    for (idx in result.errors) {
                        errMsg = errMsg.concat("\n");
                        var errMsgLine = result.errors[idx].property + " " + result.errors[idx].message;
                        var regex = /instance\[*.*\]*\./g;
                        if ((result = regex.exec(errMsgLine)) !== null) {
                            errMsgLine = errMsgLine.substring(result[0].length);
                        }
                        errMsg = errMsg.concat(errMsgLine);
                    }
                    log.info("NovacomUSB#_checkSchema()", "error!");
                    return setImmediate(next, new Error(errMsg));
                } else {
                    return setImmediate(next, null, data);
                }
            } catch (err) {
                log.info("NovacomUSB#_checkSchema()", "error!");
                return setImmediate(next, new Error("Invalid JSON Schema"));
            }
        } else {
            log.verbose("Resolver#save()#_checkSchema()", schemaFile, 'is not exist!');
            return setImmediate(next, null, data);
        }
    }

    var _getDeviceList = function (options, next) {
        log.verbose("NovacomUSB#_getNovacomDeviceList()", "options", options);
        async.parallel({
            keys: function(next) {
                var keyDir = path.resolve(process.env.HOME || process.env.USERPROFILE, '.ssh');
                var defKeyDir = path.resolve(__dirname, "setting-files", "keys");
                if (!fs.existsSync(defKeyDir)) {
                    return next();
                }
                fs.readdir(defKeyDir, function(err, files) {
                    if (err) return next(err);
                    files.forEach(function(file) {
                        if (!fs.existsSync(path.join(keyDir, file))) {
                            shelljs.cp('-rf', path.join(defKeyDir, file), keyDir);
                        }
                    })
                    next();
                });
            },
            auths: function (next) {
                var auths = {},
                    auth,
                    authFileName = path.join(options.appdir, "novacom-usb-auth.json");

                var defJsonFile = path.resolve(__dirname, "setting-files", "novacom-usb-auth.json");
                if (!fs.existsSync(defJsonFile)) {
                    return next();
                }
                if (!fs.existsSync(authFileName)) {
                    shelljs.cp('-rf', defJsonFile, options.appdir);
                }

                log.verbose("Resolver#load#_readFile()", "<<< " + authFileName);
                fs.readFile(authFileName, 'utf8', function(err, str) {
                  if (err && err.code === 'ENOENT') {
                    return setImmediate(next, null, []);
                  } else {
                    var auths = JSON.parse(str);
                    if (!Array.isArray(auths)) {
                      log.info("NovacomUSB#_getNovacomDeviceList()", "error");
                      return setImmediate(next, new Error("Incorrect file format."));
                    }
                    return setImmediate(_checkSchema, auths, path.join(__dirname, "schema/NovacomUSBAuth.schema"), next);
                  }
                });
            },
            devices: function (next) {
                var socket = new net.Socket(),
                    error,
                    novacomOutput = "";

                socket.on('error', function (err) {
                    error = err;
                });

                socket.on('close', function () {
                    if (typeof error !== 'undefined') {
                        log.info("Novacomd daemon is not running ...!", error);
                        return setImmediate(next, null, []);
                    }

                    var devices = [],
                        device,
                        deviceInfos,
                        idx,
                        port,
                        ports,
                        allDevices;
                    allDevices = novacomOutput.split('\n');

                    for (idx in allDevices) {
                        if (allDevices[idx].trim().length !== 0) {
                            deviceInfos = allDevices[idx].split(' ');
                            if (deviceInfos.length === 5 || deviceInfos.length === 6) {
                                ports = deviceInfos[4].split(':');
                                if (ports.length===2 && ports[1]) {
                                    port = parseInt(ports[0]);
                                }
                            }

                            if (typeof port === 'undefined' || !deviceInfos[5]) {
                                device = {
                                    "order": -1,
                                    "profile": "watch",
                                    "index": idx,
                                    "id": deviceInfos[1],
                                    "name": deviceInfos[2],
                                    "type": deviceInfos[3],
                                    "transport": deviceInfos[2],
                                    "description": "",
                                    "host": "127.0.0.1",
                                    "port": undefined,
                                    "files":"stream",
                                    "noPortForwarding":false,
                                    "indelible": true,
                                    "conn": ["novacom"]
                                };
                            }
                            else {
                                device = {
                                    "order": -1,
                                    "profile": "watch",
                                    "index": idx,
                                    "id": deviceInfos[1],
                                    "name": deviceInfos[2],
                                    "type": deviceInfos[3],
                                    "transport": deviceInfos[2],
                                    "device_mode": deviceInfos[5],
                                    "description": "",
                                    "host": "127.0.0.1",
                                    "port": port,
                                    "files":"stream",
                                    "noPortForwarding":false,
                                    "indelible": true,
                                    "conn": ["novacom", "ssh"]
                                };
                            }
                            //FIXME: this code consider device type as 'w2-linux' when the device is connected with 'usb'.
                            //  Later we need to change the code to support various machine name (this comes from novacom query)
                            if(('usb' === device.transport.slice(0,3))) {
                               device.type = "w2-linux";
                            }
                            devices.push(device);
                        }
                    }
                    return setImmediate(_checkSchema, devices, path.join(__dirname, "schema/NovacomUSBDevice.schema"), next);
                });

                socket.on('data', function (data) {
                    novacomOutput += data.toString();
                    socket.end();
                });
                return socket.connect({port: 6968});
            }
        },
        function (err, results) {
            var idx,
                id,
                platformKey,
                auths = {},
                devices = results.devices;

            if (err) {
                log.info("NovacomUSB#_getNovacomDeviceList()", "err", err);
                return setImmediate(next, err);
            } else {
                for (idx in results.auths) {
                    auths[results.auths[idx].id] = results.auths[idx];
                }
                for (idx in devices) {
                    id = devices[idx].id;
                    if (devices[idx].device_mode === "root") {
                        platformKey = "*" + devices[idx].type + "-root*";
                    }
                    else if (devices[idx].device_mode === "developer") {
                        platformKey = "*" + devices[idx].type + "-developer*";
                    }
                    else {
                        platformKey = "*" + devices[idx].type + "*";
                    }
                    if (auths.hasOwnProperty(id)) {
                        if (auths[id].hasOwnProperty('username'))
                            devices[idx].username = auths[id].username;
                        if (auths[id].hasOwnProperty('password'))
                            devices[idx].password = auths[id].password;
                        if (auths[id].hasOwnProperty('privateKey'))
                            devices[idx].privateKey = auths[id].privateKey;
                    } else if (auths.hasOwnProperty(platformKey)) {
                        if (auths[platformKey].hasOwnProperty('username'))
                            devices[idx].username = auths[platformKey].username;
                        if (auths[platformKey].hasOwnProperty('password'))
                            devices[idx].password = auths[platformKey].password;
                        if (auths[platformKey].hasOwnProperty('privateKey'))
                            devices[idx].privateKey = auths[platformKey].privateKey;
                    }
                }
                return setImmediate(next, null, devices);
            }
        });
    };

    var _connectTunnel = function (target, next) {
        if (typeof target.port !== 'undefined' || target.transport !== 'usb') {
            return setImmediate(next, null, target);
        }

        _getFreePort(function (err, targetPort) {
                var forward_command = _getNovacomPath() + ' -P -f ' + targetPort + ':10022 -d ' + target.id;
                child_process.exec(forward_command, {
                    encoding: 'utf8',
                    timeout: 1000,
                    maxBuffer: 200 * 1024,
                    killSignal: 'SIGTERM',
                    cwd: null,
                    env: null},
                    function(err, stdout, stderr) {
                        if (err) {
                            //if(err) throw new Error("Problem in port forwarding!" + err);
                        } else {
                        }
                    });
                target.port = targetPort;
                return setImmediate(next, null, target);
            });
    };

    var _waitDeviceConnect = function(options, next) {
        log.verbose("NovacomUSB#_waitDeviceConnect()", "options", options);

        var waitForDevice = ((typeof options === 'object') && (typeof options.waitForDevice === 'boolean')) ? options.waitForDevice : false;

        if (waitForDevice === false) {
            return setImmediate(next);
        }

        //process.stdout.write("waiting for device....");
        /* moved this msg inside _findDevice() bacause this msg should not be displayed when a device is connected */
        var firstDeviceCheck = true;
        var cnt = 0, transport_name;
        var checker = setInterval(_findDevice, 200);

        function _findDevice() {
            _getDeviceList(options, function(err, devices){
                if (err) return setImmediate(next, err);
                if (Array.isArray(devices)) {
                    devices.forEach(function(device) {
                        transport_name = device.transport;
                        if (('usb' === transport_name.slice(0,3)) || ('tcp' === transport_name.slice(0,3))){
                            process.stdout.write("\b \n\r");
                            clearInterval(checker);
                            setImmediate(next);
                        }

                    });
                }

                if(devices.length == 0 && firstDeviceCheck == true){
                    process.stdout.write("\nwaiting for device....");
                    firstDeviceCheck = false;
                }
            });

            if(firstDeviceCheck == false) {
                var mod = cnt++ % 3;
                if (mod === 0) {
                    process.stdout.write("\b/");
                } else if (mod === 1) {
                    process.stdout.write("\b-");
                } else {
                    process.stdout.write("\b\\");
                }
            }
        };
    };

    var _getNovacomUser = function (targetId, next) {
        var getUser = _getNovacomPath() + ' run \"file:///usr/bin/id -un\"' + ' -d ' + targetId;
        var cp = child_process.exec(getUser, {
            encoding: 'utf8',
            timeout: 1000,
            maxBuffer: 200 * 1024,
            killSignal: 'SIGTERM',
            cwd: null,
            env: null},
            function(err, stdout, stderr) {
                var userName;
                if (stdout) {
                    userName = stdout.toString();
                }
                setImmediate(next, err, userName);
            });
        cp.stdin.end();
    };

    var _getDeviceCmdPath = function (targetId, cmd, next) {
        var getPath = _getNovacomPath() + ' run file:///usr/bin/which ' + cmd + ' -d ' + targetId;
        var cp = child_process.exec(getPath, {
            encoding: 'utf8',
            timeout: 1000,
            maxBuffer: 200 * 1024,
            killSignal: 'SIGTERM',
            cwd: null,
            env: null},
            function(err, stdout, stderr) {
                var cmdPath;
                if (stdout) {
                    cmdPath = stdout.toString();
                }
                setImmediate(next, err, cmdPath);
            });
        cp.stdin.end();
    };

    /**
    * Run a command on the device
    * @param {String} device id
    * @param {String} cmd the device command to run
    * @param {stream.ReadableStream} stdin given as novacom process stdin
    * @param {stream.WritableStream} stdout given as novacom process stdout
    * @param {stream.WritableStream} stderr given as novacom process stderr
    * @param {Function} next commonJS callback invoked upon completion or failure
    */
    var _runDeviceCommand = function (targetId, cmd, stdin, stdout, stderr, next) {
        // plumb output
        var write = {}, obj = {};
        if (!stdout) {
            log.silly('Session#run()', "stdout: none");
            write.stdout = function() {};
        } else if (stdout instanceof stream.Stream) {
            log.silly('Session#run()', "stdout: stream");
            write.stdout = stdout.write;
            obj.stdout = stdout;
        } else if (stdout instanceof Function) {
            log.silly('Session#run()', "stdout: function");
            write.stdout = stdout;
        } else {
            setImmediate(next, new Error("Invalid novacom stdout: " + util.inspect(stdout)));
        }

        if (!stderr) {
            log.silly('Session#run()', "stderr: none");
            write.stderr = function() {};
        } else if (stderr instanceof stream.Stream) {
            log.silly('Session#run()', "stderr: stream");
            write.stderr = stderr.write;
            obj.stderr = stderr;
        } else if (stderr instanceof Function) {
            log.silly('Session#run()', "stderr: function");
            write.stderr = stderr;
        } else {
            setImmediate(next, new Error("Invalid novacom stderr: " + util.inspect(stderr)));
        }

        cmd = cmd.replace(/\"/g, "\\\"");
        var runCmdArgs
        async.series([
            function(next) {
                runCmdArgs = " run file://";
                if ('/' !== cmd[0]) {
                    cmdTokens = cmd.split(' ');
                    _getDeviceCmdPath(targetId, cmdTokens[0], function(err, cmdPath){
                        if (!cmdPath) {
                            return setImmediate(next, new Error("Unable to run " + cmdTokens[0]));
                        }
                        cmdTokens[0] = cmdPath;
                        cmd = cmdTokens.join(' ');
                        runCmdArgs += cmd;
                        next();
                    });
                } else {
                    runCmdArgs += cmd;
                    next();
                }
            },
            function(next) {
                var novacomProcess = child_process.spawn(_getNovacomPath(), [runCmdArgs],
                                                            {stdio: ['ignore', 'pipe', 'pipe']} );

                novacomProcess.stderr.on('data', function(data) {
                    write['stderr'].bind(obj['stderr'])(data);
                });

                novacomProcess.stdout.on('data', function(data) {
                    write['stdout'].bind(obj['stdout'])(data);
                });

                novacomProcess.on('exit', function(code) {
                    setImmediate(next);
                });
            }

        ],function(err) {
            setImmediate(next, err);
        })
    };

    // NOVACOM_USB INTERFACE
    novacom_usb.getDeviceList = _getDeviceList;
    novacom_usb.connectTunnel = _connectTunnel;
    novacom_usb.waitDeviceConnect = _waitDeviceConnect;
    novacom_usb.getNovacomPath = _getNovacomPath;
    novacom_usb.getNovacomDaemonPath = _getNovacomDaemonPath;
    novacom_usb.getNovacomUser = _getNovacomUser;
    novacom_usb.runDeviceCommand = _runDeviceCommand;
})();
