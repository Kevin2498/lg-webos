var
    exec = require('child_process').exec,
    log = require('npmlog'),
    Promise = require('bluebird'),
    path = require('path');

var
    dns = Promise.promisifyAll(require('dns')),
    fs = Promise.promisifyAll(require('fs-extra')),
    git = Promise.promisifyAll(require('gift'));

var
    openUrl = require('./openurl'),
    promiseMaker = require('./promisemaker');

var gitInstUrls = {
    win32: "https://www.npmjs.com/package/bower#windows-users",
    darwin: "https://git-scm.com/book/en/v2/Getting-Started-Installing-Git#Installing-on-Mac",
    linux: "https://git-scm.com/book/en/v2/Getting-Started-Installing-Git#Installing-on-Linux"
};

function Gitter() {}

Gitter.prototype = {
    verifyGit: function(options) {
        log.verbose("verifyGit()");
        var cmd = 'git --version';
        var child = exec(cmd, {});
        return dns.lookupAsync('www.github.com')
            .then(function() {
                return promiseExec(cmd, {});
            })
            .then(function() {
                log.verbose("verifyGit()", "'git' command is available on this machine.");
                return;
            })
            .catch(function(err) {
                log.verbose("verifyGit()#error", err);
                if (err && err.code == "ENOTFOUND") {
                    err = new Error("Network is not available.");
                }
                else if (err && err.exitCode) {
                    if (err.exitCode !== 0) {
                        err = new Error("'git' command is not available on this machine.");
                        if (options && options.openUrl) {
                            openUrl(gitInstUrls[process.platform]);
                        }
                    }
                }
                throw err;
            });
    },
    shallowClone: function(addr, dir, branch) {
        log.verbose("shallowClone()#git.cloneAsync() start:", addr, ", branch:", branch);
        return git.cloneAsync(addr, dir, 1, branch)
            .then(function(repo) {
                log.verbose("shallowClone()#git.cloneAsync() done in ", dir);
                return "Success";
            })
            .catch(function(err) {
                throw err;
            });
    },
    unshallowRepo: function(dir) {
        //TODO: In dir,
        // git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*";
        // git fetch origin
        log.verbose('unshallowRepo()', 'convert shallow clone to full clone at', dir);
        var cmd;
        return Promise.resolve()
            .then( function() {
                cmd = "git config remote.origin.fetch \"+refs/heads/*:refs/remotes/origin/*\"";
                log.verbose('unshallowRepo()#cmd:', cmd, 'at', dir);
                return promiseExec(cmd, {cwd: dir})
            })
            .then(function() {
                cmd = 'git fetch origin';
                log.verbose('unshallowRepo()#cmd:', cmd, 'at', dir);
                return promiseExec(cmd, {cwd: dir});
            })
            .then(function() {
                log.verbose('unshallowRepo() done');
                return;
            })
            .catch(function(err) {
                if (err.hasOwnProperty('exitCode')) {
                    log.warn('unshallowRepo()#cmd:', cmd, ", exitCode:", err.exitCode);
                }
                throw err;
            })
    },
    checkoutRepo: function(dir, branch) {
        log.verbose("checkoutRepo()#branch:", branch, 'at', dir);
        return git.initAsync(dir)
            .then(function(repo) {
                var repoPm = Promise.promisifyAll(repo);
                return repoPm.checkoutAsync(branch);
            })
            .then(function() {
                log.verbose('checkoutRepo() done.', 'at', dir);
                return;
            })
            .catch(function(err) {
                log.error('checkoutRepo() failed at '+ dir + ' during checking out to ' + branch)
                throw err;
            });
    }
}

function promiseExec(cmd, options) {
    log.verbose("promiseExec()#cmd:", cmd);
    var child = exec(cmd, options);
    child.stdout.on('data', log.verbose.bind(log, 'promiseExec()'));
    child.stderr.on('data', log.verbose.bind(log, 'promiseExec()'));
    return promiseMaker(child);
}

module.exports = Gitter;
