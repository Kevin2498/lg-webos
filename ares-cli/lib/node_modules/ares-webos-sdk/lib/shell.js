var async = require('async'),
    path = require('path'),
    npmlog = require('npmlog'),
    fs = require('fs'),
    childprocess = require('child_process'),
    novacom = require('./novacom'),
    errMsgHndl = require('./error-handler'),
    novacomusb = require('./novacom-usb');

(function() {

    var log = npmlog;

    log.heading = 'logger';
    log.level = 'warn';


    var shell = {

        log: log,

        remoteRun: function(options, runCommand, next) {
            log.info('shell#remoteRun()');
            var session = new novacom.Session(options, function(err, result) {
                log.verbose("run()", "run:", runCommand);
                log.verbose("run()", "options:", options);
                if (err) {
                    next(err);
                    return;
                }
                session.run(runCommand, process.stdin, process.stdout, process.stderr, next);
            });
        },

        shell: function(options, next) {
            async.waterfall([
                function(next) {
                    new novacom.Session(options, next);
                },
                function(session, next) {
                    var conn_type;
                    if (session.target.conn) {
                        if (session.target.conn.indexOf('ssh') !== -1)
                            _ssh(session, next);
                        else
                            _nova(session, next);
                    } else {
                        _ssh(session, next);
                    }
                }
            ], function(err, conn) {
                setImmediate(next, err);
            });

            var _nova = function(session, finish) {
                var spawn = require('child_process').spawn;
                var novacomPath = novacomusb.getNovacomPath();
                var procNova = spawn(novacomPath, ['-t','open','tty://', '-d', session.target.id]);
                process.stdout.write(">>> Start " + session.getDevice().name + " shell.\n");
                process.stdout.write(">>> Type `exit` to quit.\n\n");
                procNova.stdout.pipe(process.stdout);
                process.stdin.pipe(procNova.stdin);
                procNova.on('exit', function(code, signal) {
                        process.stdout.write("\n>>> Terminate the shell, bye.\n\n");
                        log.silly('Stream :: exit :: code: ' + code + ', signal: ' + signal);
                        finish();
                });
            }

            var _ssh = function(session, finish) {
                log.info('shell#shell()');
                async.series([
                    function(next) {
                        if (!session) {
                            session = new novacom.Session(options, next);
                        } else {
                            setImmediate(next);
                        }
                    },
                    function(next) {
                        var winOpts = {
                            //"rows": process.stdout.rows,
                            //"columns": process.stdout.columns,
                            "term": 'screen'
                        };
                        session.ssh.shell(winOpts, function(err, stream) {
                            if (err) {
                                return setImmediate(next, errMsgHndl.changeErrMsg(err));
                            }
                            open_shell();
                            function open_putty_shell() {
                                var keydir = path.resolve(process.env.HOME || process.env.USERPROFILE, '.ssh');
                                var key_path = keydir + '\\' + session.target.privateKeyName + ".ppk";
                                fs.exists(key_path, function(exist) {
                                    if (exist) {
                                        var flag = true;
                                        var puttyCmd = childprocess.exec("putty.exe" +
                                            " -ssh " + session.target.username + "@" + session.target.host +
                                            " -P " + session.target.port + " -i " + key_path);
                                        puttyCmd.on('exit', function(err) {
                                            if (flag) {
                                                finish(err, true);
                                            }
                                        });

                                        puttyCmd.stderr.on('data', function (data) {
                                            flag = false;
                                            open_shell();
                                        });
                                    }
                                    else {
                                        open_shell();
                                    }
                                });
                            }
                            function open_shell() {
                                stream.on('exit', function(code, signal) {
                                    process.stdout.write("\n>>> Terminate the shell, bye.\n\n");
                                    log.silly('Stream :: exit :: code: ' + code + ', signal: ' + signal);
                                    session.ssh.end();
                                    next();
                                });

                                stream.on('data', function(code, signal) {
                                    arrangeWindow(stream);
                                });

                                process.stdout.on('resize', function() {
                                    arrangeWindow(stream);
                                });

                                process.stdout.write(">>> Start " + session.getDevice().name + " shell.\n");
                                process.stdout.write(">>> Type `exit` to quit.\n\n");
                                process.stdin.setRawMode(true);
                                process.stdin.pipe(stream);
                                stream.pipe(process.stdout);

                                function arrangeWindow(stream) {
                                    if (winOpts.rows !== process.stdout.rows || winOpts.columns !== process.stdout.columns) {
                                        stream.setWindow(process.stdout.rows, process.stdout.columns);
                                        winOpts.rows = process.stdout.rows;
                                        winOpts.columns = process.stdout.columns;
                                    }
                                }
                            }
                        });
                    }
                ], function(err, result) {
                    var flag_reboot = false;
                    if (result.indexOf("id") > 0) {
                        flag_reboot = true;
                    }
                    finish(err,flag_reboot);
                });
            }
        }
    };

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = shell;
    }
}());
