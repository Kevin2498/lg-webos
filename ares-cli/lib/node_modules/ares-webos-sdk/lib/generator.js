#!/usr/bin/env node

"use strict"

var
    path = require('path'),
    Promise = require('bluebird'),
    inq = require('inquirer'),
    log = require('npmlog'),
    Table = require('easy-table');

var
    fs = Promise.promisifyAll(require('fs-extra'));

var
    readJsonSync = require('./util/json').readJsonSync,
    readJsonAsync = require('./util/json').readJsonAsync,
    copyToDirAsync = require('./util/copy').copyToDirAsync,
    merge = require('./util/merge'),
    Git = require('./util/git');

var git = new Git();

function Generator(tmplFile) {
    var templates;

    function _setTemplates(tmplFile) {
        if (tmplFile) {
            var cliPath = path.join(__dirname, '..');
            var contents = fs.readFileSync(tmplFile);
            contents = contents.toString().replace(/\$cli-root/gi, cliPath).replace(/\\/g,'/');
            templates = JSON.parse(contents);
        } else {
            templates = null;
        }
    }
    _setTemplates(tmplFile);
    this.setTmplates = _setTemplates;
    this.getTemplates = function() {
        return templates;
    };
}

Generator.prototype.showTemplates = function(tmplFile, listType) {
    var templates = this.getTemplates();
    var table = new Table();
    var _displayType = {
        "webapp": "Web App",
        "nativeapp": "Native App",
        "webappinfo": "Web App Info",
        "nativeappinfo": "Native App Info",
        "jsservice": "JS Service",
        "nativeservice": "Native Service",
        "jsserviceinfo": "JS Service Info",
        "nativeserviceinfo": "Native Service Info",
        "icon": "Icon",
        "library": "Library"
    }
    for (var name in templates) {
        if (templates[name].hide === true || !templates[name].type) continue;
        var isDefault = (templates[name].default) ? "(default) " : "";
        var branch = templates[name].branch || '-';
        var type = _displayType[templates[name].type] || templates[name].type;
        if (listType && ["true", "false", true, false].indexOf(listType) === -1) {
            if (templates[name].type &&
                (templates[name].type.match(new RegExp(listType+"$","gi")) === null)) {
                continue;
            }
        }
        table.cell('ID', name);
        table.cell('Project Type', type);
        table.cell('Version', branch);
        table.cell('Description', isDefault + templates[name].description);
        table.newRow()
    }
    console.log(table.print());
    return;
}

Generator.prototype.generate = function(options) {
    var
        tmplFile = options.tmplFile,
        tmplName = options.tmplName,
        appinfo = options.appinfo,
        svcName = options.svcName,
        overwrite = !!options.overwrite,
        useInquirer = !!options.query,
        out = options.out;

    var
        svcinfo,
        templates = this.getTemplates(),
        dest = path.resolve(out),
        template = templates[tmplName];

    if (!template || tmplName === 'requireCommands') {
        return Promise.reject(new Error('Invalid template name'));
    }

    if (template.metadata && template.metadata.data &&
        typeof template.metadata.data === 'object') {
        appinfo = merge(appinfo, template.metadata.data)
    }
    if (svcName) {
        svcinfo = {};
        svcinfo['id'] = svcName;
        svcinfo['services'] = [{
            "name": svcName
        }];
    }

    return Promise.resolve()
        .then(function() {
            if (templates.requireCommands && templates.requireCommands.indexOf('git') !== -1) {
                return git.verifyGit({openUrl:true});
            }
            return;
        })
        .then(function() {
            try {
                var files = fs.readdirSync(dest);
                var questions = [{
                    type: "confirm",
                    name: "overwrite",
                    message: "The directory already exists, overwrite?",
                    default: false,
                    when: function(answers) {
                        return !overwrite && useInquirer && files.length > 0;
                    }
                }];
                return inq.prompt(questions).then(function(answers) {
                    options.overwrite = answers.overwrite || options.overwrite;
                    if (files.length > 0 && !options.overwrite) {
                        throw new Error(dest + " is not empty. Please check the directory.");
                    }
                });
            } catch (err) {
                if (err && err.code === 'ENOTDIR') {
                    throw new Error(dest + " is not a directory. Please check the directory path.");
                }
                if (err && err.code === 'ENOENT') {
                    log.verbose("Generator.generate()", "The directory does not exist.");
                    return;
                }
                throw err;
            }
        })
        .then(function() {
            log.verbose("Generator.generate()", "template name:" + tmplName);
            console.log("Generating " + tmplName + " in " + dest);
            if (template.type.match(/info$/)) {
                return _writeMetadata(template, appinfo, svcinfo);
            }
            else if(template.type.match(/^Hosted/)) {
                var srcs = [].concat(template.path);
                return Promise.all(srcs.map(function(src) {
                    return copyToDirAsync(src, dest);
                })).then(function() {
                    var metaTmpl;
                    var url;
                    if (template.metadata && template.metadata.id) {
                        metaTmpl = templates[template.metadata.id];
                    }
                    if (metaTmpl) {
                        if(appinfo.url){
                            url = appinfo.url;
                            delete appinfo.url;
                            var urlTmpl = {"path":path.join(srcs[0],'index.html')};
                            _writeURLdata(urlTmpl, url);
                        }
                        return _writeMetadata(metaTmpl, appinfo, svcinfo);
                    } else {
                        return;
                    }
                });
            }
            else {
                var srcs = [].concat(template.path);
                return Promise.all(srcs.map(function(src) {
                    log.verbose("Generator.generate()", "template src:" + src);
                    return copyToDirAsync(src, dest);
                })).then(function() {
                    var metaTmpl;
                    if (template.metadata && template.metadata.id) {
                        metaTmpl = templates[template.metadata.id];
                    }
                    if (metaTmpl) {
                        return _writeMetadata(metaTmpl, appinfo, svcinfo);
                    } else {
                        return;
                    }
                });
            }
        })
        .then(function() {
            var deps = templates[tmplName].deps || [];
            return Promise.all(deps.map(function(dep) {
                if (!templates[dep]) {
                    log.warn("Generator.generate()", "Invalid template id " + dep);
                    return;
                } else if (!templates[dep].path) {
                    log.warn("Generator.generate()", "Invalid template path " + dep);
                    return;
                }
                return copyToDirAsync(templates[dep].path, dest);
            }));
        })
        .then(function() {
            if (template.type.match(/info$/) || template.type.match(/icon$/)) {
                return;
            }
            log.verbose("Generator.generate()", "target branch is " + templates[tmplName].branch);
            var enyoConfigFile;
            enyoConfigFile = path.join(dest, '.enyoconfig');
            try {
                fs.accessSync(enyoConfigFile, fs.F_OK);
                return readJsonAsync(enyoConfigFile)
                    .then(function(enyoConfig) {
                        return _downloadLibs(enyoConfig, dest, templates[tmplName].branch, options.overwrite);
                    })
                    .then(function(enyoConfig) {
                        if (enyoConfig && enyoConfig.targets) {
                            for (var key in enyoConfig.targets) {
                                if (enyoConfig.targets[key] !== templates[tmplName].branch) {
                                    enyoConfig.targets[key] = templates[tmplName].branch;
                                }
                            }
                            return fs.writeFileAsync(enyoConfigFile, JSON.stringify(enyoConfig, null, 2));
                        } else {
                            return;
                        }
                    })
            } catch(err) {
                if (err && err.code === 'ENOENT') {
                    log.verbose("Generator.generate()", enyoConfigFile + " does not exist.");
                    return;
                }
                throw err;
            }
        })
        .then(function() {
            log.verbose("Generator.generate() done.");
            return {
                msg: "Success"
            };
        })
        .catch(function(err) {
            log.verbose("Generator.generate()#err:", err);
            throw err;
        });

    function _writeURLdata(urlTmpl, url) {
        var filePaths = [].concat(urlTmpl.path);
        return Promise.all(filePaths.map(function(file) {
            return fs.lstatAsync(file)
                .then(function(stats) {
                    if (!stats.isFile()) {
                        var msg = "Invalid metadata template path:" + file;
                        log.warn("Geneator.generate()._writeURLdata()#warn", "Invalid metadata template path:" + file);
                        throw new Error(msg);
                    }
                    var html = fs.readFileSync(file, 'utf8');
                    var exp = new RegExp("(?:[\'\"])([\:/.A-z?<_&\s=>0-9;-]+\')");
                    html=html.replace(exp, "\'"+url+"\'");
                    var fileName = path.basename(file);
                    var destFile = path.join(dest, path.basename(file));
                    fs.writeFileAsync(destFile, html, {encoding: 'utf8'});
                })
        }))
        .then( function(results) {
            log.verbose("Geneator.generate()._writeMetadata() done.");
            return;
        })
        .catch( function(err) {
            log.verbose("Geneator.generate()._writeMetadata()#err:", err);
            throw err;
        })
    }

    function _writeMetadata(metaTmpl, appinfo, svcinfo) {
        log.verbose("Generator.generate()._writeMetadata()")
        var metaPaths = [].concat(metaTmpl.path),
            appinfo = appinfo || {},
            svcinfo = svcinfo || {};

        return Promise.all(metaPaths.map(function(file) {
            return fs.lstatAsync(file)
                .then(function(stats) {
                    if (!stats.isFile()) {
                        var msg = "Invalid metadata template path:" + file;
                        log.warn("Geneator.generate()._writeMetadata()#warn", "Invalid metadata template path:" + file);
                        throw new Error(msg);
                    }
                    var info = readJsonSync(file);
                    var fileName = path.basename(file);
                    if (fileName === 'appinfo.json') {
                        info = merge(info, appinfo);
                    } else if (fileName === "services.json") {
                        info = merge(info, svcinfo)
                    } else if (fileName === "package.json" &&
                        (metaTmpl.type === "jsserviceinfo" || metaTmpl.type === "nativeserviceinfo")) {
                        info['name'] = svcinfo.id || info['name'];
                    }
                    return info;
                })
                .then(function(info) {
                    var destFile = path.join(dest, path.basename(file));
                    return fs.mkdirsAsync(dest)
                        .then(function() {
                            return fs.writeFileAsync(destFile, JSON.stringify(info, null, 2), {
                                encoding: 'utf8'
                            })
                        });
                })
        }))
        .then( function(results) {
            log.verbose("Geneator.generate()._writeMetadata() done.");
            return;
        })
        .catch( function(err) {
            log.verbose("Geneator.generate()._writeMetadata()#err:", err);
            throw err;
        })
    }

    function _downloadLibs(enyoConfig, dest, target, overwrite) {
        var config = enyoConfig;
        var gitUrls = [];
        for (var key in config.sources) {
            gitUrls.push({
                url: config.sources[key],
                target: target || config.targets[key],
                locate: (config.locates) ? path.join(dest, config.locates[key]) : path.join(dest, 'lib')
            });
        }

        return Promise.all(gitUrls.map(function(gitUrl) {
            try {
                fs.accessSync(gitUrl.locate, fs.F_OK);
                if (!overwrite) {
                    throw new Error(gitUrl.locate + ' exits. Please set "overwrite".');
                }
                log.verbose("_downloadLibs()#Removing an existing directory at ", gitUrl.locate);
                return fs.removeAsync(gitUrl.locate).then(function() {
                    return git.shallowClone(gitUrl.url, gitUrl.locate, gitUrl.target);
                })
            } catch (err) {
                if (err && err.code === 'ENOENT') {
                    log.verbose("_downloadLibs()", gitUrl.locate + " does not exists. start git shallow clone.");
                    return git.shallowClone(gitUrl.url, gitUrl.locate, gitUrl.target);
                }
            }
        }))
        .then(function(results) {
            log.verbose("_downloadLibs() done.");
            return enyoConfig;
        })
        .catch(function(err) {
            log.verbose("_downloadLibs()#err:", err);
            throw err;
        });
    }
}

Generator.prototype.init = function(options) {
    var
        stats,
        dest = path.resolve(options.out),
        enyoConfigFile = path.join(dest, '.enyoconfig');

    log.verbose("Generator.init()", "options:" + options);
    try {
        stats = fs.statSync(dest);
        if (!stats.isDirectory()) {
            throw new Error(dest + " is not a directory.");
        }
    } catch(err) {
        if (err && err.code === 'ENOENT') {
            throw new Error(dest + " does not exist.");
        }
    }
    return Promise.resolve()
        .then(function() {
            return git.verifyGit({openUrl:true});
        })
        .then(function() {
            try {
                var enyoConfig;
                fs.accessSync(enyoConfigFile, fs.F_OK);
                enyoConfig = readJsonSync(enyoConfigFile);
                console.log("Initializing as described in " + enyoConfigFile);
                return _checkoutLibs(enyoConfig, dest);
            } catch(err) {
                if (err && err.code === 'ENOENT') {
                    err = new Error(enyoConfigFile + " does not exist.");
                }
                throw err;
            }
        })
        .then(function() {
            log.verbose("Generator.init() done");
            return {
                msg: "Success"
            };
        })
        .catch(function(err) {
            log.verbose("Generator.init() err:", err);
            throw err;
        });

    function _checkoutLibs(enyoConfig, dest) {
        var
            config = enyoConfig,
            gitUrls = [];

        log.verbose("Generator.init()._checkoutLibs()");
        for (var key in config.sources) {
            gitUrls.push({
                url: config.sources[key],
                target: config.targets[key],
                locate: (config.locates) ? path.join(dest, config.locates[key]) : path.join(dest, 'lib')
            });
        }

        return Promise.all(gitUrls.map(function(gitUrl) {
            try {
                fs.accessSync(gitUrl.locate);
                return git.unshallowRepo(gitUrl.locate)
                    .then(function() {
                        return git.checkoutRepo(gitUrl.locate, gitUrl.target);
                    })
            } catch(err) {
                if (err && err.code === 'ENOENT') {
                    log.verbose("Generator.init()._checkoutLibs()", gitUrl.locate + " does not exist.");
                    log.verbose("Generator.init()._checkoutLibs()", "git shallow clone " + gitUrl.url + " # branch: " + gitUrl.target);
                    return git.shallowClone(gitUrl.url, gitUrl.locate, gitUrl.target);
                }
                throw err;
            }
        })).then(function(results) {
            log.verbose("Generator.init()._checkoutLibs() done.");
            return;
        }).catch(function(err) {
            log.verbose("Generator.init()._checkoutLibs()#err:", err);
            throw err;
        })
    }
}

module.exports = Generator;
